{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Trial design visualization TD is a command line tool written in python to create overview figures for clinical study designs, and to summarize relevant elements of the schedule of assessments. The input describing the study design is expected as a json-formatted text file. The output is provided in vector graphic form (as a .svg file) that can be easily included in Office documents or websites. Getting started Go to Use for guidance how to install and run the tool. The Input page describes the structure and syntax of the input required to generate Code documentation A detailed documentation of the python code is provided in the Code documentation section.","title":"Home"},{"location":"#trial-design-visualization","text":"TD is a command line tool written in python to create overview figures for clinical study designs, and to summarize relevant elements of the schedule of assessments. The input describing the study design is expected as a json-formatted text file. The output is provided in vector graphic form (as a .svg file) that can be easily included in Office documents or websites.","title":"Trial design visualization"},{"location":"#getting-started","text":"Go to Use for guidance how to install and run the tool. The Input page describes the structure and syntax of the input required to generate","title":"Getting started"},{"location":"#code-documentation","text":"A detailed documentation of the python code is provided in the Code documentation section.","title":"Code documentation"},{"location":"about/","text":"About This is a command line tool to create high-quality study design overview figures for clinical studies. TD uses a json-formatted input file to specify the study design elements and has a number of options to further specify the graphical output. TD is written in functional python by Rainer Strotmann ( @auchkunscht ).","title":"About"},{"location":"about/#about","text":"This is a command line tool to create high-quality study design overview figures for clinical studies. TD uses a json-formatted input file to specify the study design elements and has a number of options to further specify the graphical output. TD is written in functional python by Rainer Strotmann ( @auchkunscht ).","title":"About"},{"location":"input/","text":"Input file format The td.py tool expects a json-formatted input file (see Use ) that specifies the study elements to be rendered. In general, the json format has specific syntactic requirements in order to be read correctly by TD: All json elements are enclosed in curly brackets, including the complete input file Fields within elements have a name that must be enclosed in quotes, e.g., \"caption\", followed by a colon and the respective value Values can be numerical, character (i.e., enclosed in quotes), other json elements, or lists (enclosed in square brackets) of any of the previous Fields must be separated by commas, but there is no comma after the respective last element The below overview specifies the specific expected format of the json-formatted input file to describe the trial design elements. Periods On the highest level, clinical study elements within the input file are expected to be structured in periods or cycles . Both options are possible and essentially equivalent. As a minimum, each period or cycle element needs to have caption , start and duration fields. A minimum period \"Period 1\" that includes days 1 through 7 is described like this: { \"caption\": \"Period 1\", \"start\": 1, \"duration\": 7 } Note that the period definition is enclosed in curly brackets. In the json format, this is used to structure elements. You will see below that objects can themselves contain objects. In additino, some elements are grouped together in a list. Lists are delimited in square brackets. In the input file, periods, even if only one is defined, are expected as a periods list. A minimal viable input file could look like this: { \"periods\": [ { \"caption\": \"Period 1\", \"start\": 1, \"duration\": 7 } ] } The respective output is: Further periods can be added as more members to periods , e.g.: { \"periods\": [ { \"caption\": \"Period 1\", \"start\": 1, \"duration\": 7 }, { \"caption\": \"Period 2\", \"start\": 1, \"duration\": 7 } ] } Period formatting Additional fields can be added to the period elements to specify the visual output. Each period can have the following fields: daylabels , a list of days for which daynumbers will be printed. dayshading , a list of days for which the day box will have a grey background. This can be used to highlight relevant days, e.g., weekend days. { \"periods\": [ { \"caption\": \"Period 1\", \"start\": -1, \"duration\": 8, \"daylabels\": [-1, 1, 2, 3, 6, 7], \"dayshading\": [1, 7] } ] } Note Wherever lists of days are expected as the input to a field, there are different options. In the simplest case, a list of day numbers can be provided: [-1, 1, 2, 3, 5, 7] If subsequent days are to be specified, it may be more convenient to use a range format. Note that ranges need to be provided with enclosing double quotes. Individual days and ranges can be combined: [-1, \"1-3\", 5, 7] Period elements To every period , elements can be appended. There are three classes of elements: intervals , administrations and procedures . Individual elements of these classes must be given as a list of the respective types (see examples below). This results in a hierarchical structure of the input file where lists can have members that themselves may contain lists of child elements. To better visualize the hierarchy, successive indentation levels are used in the json blocks shown in this documentation. Note that this is not a strict requirement for the json-formatted input file, however it is considered good practice. The three element classes have different visual representations and may have different property fields. The following gives an overview on this. Intervals Intervals are typically used to denote hospitalization phases or ambulatory visits, and are represented in the output as boxes spanning the respective days. There are two different ways of specifying intervals: For intervals that span multiple days, a start and duration must be given. For single-day intervals, a list of days can be given instead. The duration is then assumed to be one day. A valid example may look like this: { \"periods\": [ { \"caption\": \"Period 1\", \"start\": -1, \"duration\": 10, \"daylabels\": [-1, \"1-9\"], \"intervals\": [ { \"caption\": \"hospitalization\", \"start\": -1, \"duration\": 4 }, { \"caption\": \"ambulatory visit\", \"days\": [5, 7, 9] } ] } ] } Administrations IMP administrations are shown in the output using arrow symbols. The minimally required fields are caption and days . As mentioned above , days is expected to be a list of numbers or double-quoted day ranges. Both are used in the below example: { \"periods\": [ { \"caption\": \"Period 1\", \"start\": -1, \"duration\": 10, \"daylabels\": [-1, \"1-9\"], \"administrations\": [ { \"caption\": \"aspirin\", \"days\": [1] }, { \"caption\": \"paracetamole\", \"days\": [5, 6, 7] } ] }, { \"caption\": \"Period 2\", \"start\": 10, \"duration\": 4, \"daylabels\": [\"10-14\"], \"administrations\": [ { \"caption\": \"aspirin\", \"days\": [11] } ] } ] } Procedures All other study assessments (e.g., blood sampling, ECG, etc.) are specified as procedures . In general, study procedures may be conducted once per day or multiple times per day. In the graphical representation, the respective symbols are diamonds and boxes. The frequency of a procedure can be specified using the freq field: \"QD\" indicates once daily, while \"rich\" indicates multiple daily time points. For \"QD\", the freq field can also be omitted (e.g., for the ECG on day 5, below). { \"periods\": [ { \"caption\": \"Period 1\", \"start\": -1, \"duration\": 8, \"daylabels\": [-1, \"1-7\"], \"procedures\": [ { \"caption\": \"ECG\", \"days\": [-1], \"freq\": \"QD\" }, { \"caption\": \"ECG\", \"days\": [5] }, { \"caption\": \"ECG\", \"days\": [7], \"freq\": \"rich\" } ] } ] } Advanced notation Exact procedure times As a more granular alternative to the rather coarse definition of the procedure frequency using the freq field, precise preocedure times can be noted for procedures, e.g., for PK samplings. The times (in hours) is to be provided as a list to the times field. In addition, a relative field must be provided to clearly indicate to which day the times refer: { \"periods\": [ { \"caption\": \"Period 1\", \"start\": -1, \"duration\": 8, \"daylabels\": [-1, \"1-7\"], \"procedures\": [ { \"caption\": \"ECG\", \"days\": [1], \"times\": [0, 0.5, 1, 2, 4, 6, 8, 12, 24, 36, 48], \"relative\": 1 } ] } ] } This notation automatically assigns the right symbols for the days onto which the time points fall. In the above example, the time point list indicates that there are multiple time points on days 1 and 2 (leading to a box symbol for these days) but a single time point on day 2 (diamond symbol): Sometimes, it is desirable to print a more detailed timeline for a procedure (e.g., to show the PK sampling schedule). This can be achieved by adding a timescale field with the value \"show\". In addition, as described on the Use page, the commandline parameter --timescale (or short -t ) must be set to achieve this. { \"periods\": [ { \"caption\": \"Period 1\", \"start\": -1, \"duration\": 8, \"daylabels\": [-1, \"1-7\"], \"procedures\": [ { \"caption\": \"PK sampling\", \"days\": [1], \"times\": [0, 0.5, 1, 2, 4, 6, 8, 12, 24, 36, 48], \"relative\": 1, \"timescale\": \"show\" } ] } ] } (Created by invoking: python td.py -t sample.jpg ) Exact dose information In some cases, the dose for an IMP changes over time in a scheduled way, e.g. to phase in or out a sensitive drug. In this cases, the respective administration element can include specific dosing information using a numerical dose field. The below example shows a dose escalation for carbamazepine: \"administrations\": [ { \"caption\": \"carbamazepine BID\", \"days\": [\"8-9\"], \"dose\": 100 }, { \"caption\": \"carbamazepine BID\", \"days\": [\"10-11\"], \"dose\": 200 }, { \"caption\": \"carbamazepine BID\", \"days\": [\"12-32\"], \"dose\": 300 } ] As detailed on the Use page, a dose graph can then be displayed in the output to indicate the dose over time using the \"--graph\" (or \"-g\") option. Other procedure symbols In cases where prodecure symbols should indicate different conditions (e.g., fasted vs. fed), a value field can be included in the procedure element. Procedures with a value field are not shown as diamonds but as hollow circles if the value is zero, and filled circles for any value other than zero: { \"periods\": [ { \"caption\": \"Period 1\", \"start\": -1, \"duration\": 8, \"daylabels\": [-1, \"1-7\"], \"procedures\": [ { \"caption\": \"food\", \"days\": [1], \"value\": 0 }, { \"caption\": \"food\", \"days\": [5], \"value\": 1 } ] } ] } Period highlighting To visually make a period stand out, the period element can include a decoration field. Possible values are \"highlighted\" for a shaded background or \"bracketed\" to indicate, e.g., optional periods. Setting the value to \"none\" removes the effect, this can be used for quick testing purposes. { \"periods\": [ { \"caption\": \"Period 1\", \"start\": -1, \"duration\": 5, \"daylabels\": [-1, \"1-4\"], \"decoration\": \"highlighted\", \"procedures\": [ { \"caption\": \"massage\", \"days\": [\"1-2\"] } ] }, { \"caption\": \"Period 2\", \"start\": 1, \"duration\": 4, \"daylabels\": [\"1-4\"], \"procedures\": [ { \"caption\": \"massage\", \"days\": [\"1-2\"] } ] }, { \"caption\": \"Period 3\", \"start\": 1, \"duration\": 4, \"daylabels\": [\"1-4\"], \"decoration\": \"bracketed\", \"procedures\": [ { \"caption\": \"massage\", \"days\": [ \"1-2\"] } ] } ] } Procedure labels To annotate individual procedure instances, e.g., to give visits a unique identifier (see below) or to add details to a procedure on a certain day, the labels field can be added to a procedure. Its value is expected to be a list of labels corresponding to the list of days of that procedure. Labels are rendered in the output above the respective days. Lables can be added to intervals, administrations or procedures. Note: If the procedure is an interval that is defined using start and duration , that list is expected to contain only one label which is then displayed above the start day of the interval: { \"periods\": [ { \"caption\": \"Period 1\", \"start\": -1, \"duration\": 10, \"daylabels\": [-1, \"1-9\"], \"intervals\": [ { \"caption\": \"hospitalization\", \"start\": -1, \"duration\": 4, \"labels\": [\"V1\"] }, { \"caption\": \"ambulatory visit\", \"days\": [5, 7, 9], \"labels\": [\"V2\", \"V3\", \"V4\"] } ] } ] } Footnotes Footnotes can be added to any interval , administration or procedure field, defining an entry footnotes that has a list as its value. The elements of that list need to have days , symbol and text entires that define the days to be annotated, the footnote symbol to be rendered above it, and the full text that is rendered at the bottom of the output. Footnote symbols can be re-used in other procedures. the text field in further copies is expected to be an empty string (i.e., \"\"). Note that in the output, footnotes are only rendered if specified explicitly with the \"--footnote\" (or \"-n\") option (see Use ). The below figure was created by invoking python td.py -n sample.jpg : { \"periods\": [ { \"caption\": \"Periods 1-3\", \"start\": -1, \"duration\": 8, \"daylabels\": [-1, \"1-7\"], \"procedures\": [ { \"caption\": \"ECG\", \"days\": [ 1, 2, 3, 7], \"footnotes\": [ { \"days\": [2, 7], \"symbol\": \"a\", \"text\": \"Period 1 only\" }, { \"days\": 7, \"symbol\": \"b\", \"text\": \"Before discharge\" } ] }, { \"caption\": \"vital signs\", \"days\": [-1, 5, 7], \"footnotes\": [ { \"days\": 5, \"symbol\": \"a\", \"text\": \"\" } ] } ] } ] }","title":"Input"},{"location":"input/#input-file-format","text":"The td.py tool expects a json-formatted input file (see Use ) that specifies the study elements to be rendered. In general, the json format has specific syntactic requirements in order to be read correctly by TD: All json elements are enclosed in curly brackets, including the complete input file Fields within elements have a name that must be enclosed in quotes, e.g., \"caption\", followed by a colon and the respective value Values can be numerical, character (i.e., enclosed in quotes), other json elements, or lists (enclosed in square brackets) of any of the previous Fields must be separated by commas, but there is no comma after the respective last element The below overview specifies the specific expected format of the json-formatted input file to describe the trial design elements.","title":"Input file format"},{"location":"input/#periods","text":"On the highest level, clinical study elements within the input file are expected to be structured in periods or cycles . Both options are possible and essentially equivalent. As a minimum, each period or cycle element needs to have caption , start and duration fields. A minimum period \"Period 1\" that includes days 1 through 7 is described like this: { \"caption\": \"Period 1\", \"start\": 1, \"duration\": 7 } Note that the period definition is enclosed in curly brackets. In the json format, this is used to structure elements. You will see below that objects can themselves contain objects. In additino, some elements are grouped together in a list. Lists are delimited in square brackets. In the input file, periods, even if only one is defined, are expected as a periods list. A minimal viable input file could look like this: { \"periods\": [ { \"caption\": \"Period 1\", \"start\": 1, \"duration\": 7 } ] } The respective output is: Further periods can be added as more members to periods , e.g.: { \"periods\": [ { \"caption\": \"Period 1\", \"start\": 1, \"duration\": 7 }, { \"caption\": \"Period 2\", \"start\": 1, \"duration\": 7 } ] }","title":"Periods"},{"location":"input/#period-formatting","text":"Additional fields can be added to the period elements to specify the visual output. Each period can have the following fields: daylabels , a list of days for which daynumbers will be printed. dayshading , a list of days for which the day box will have a grey background. This can be used to highlight relevant days, e.g., weekend days. { \"periods\": [ { \"caption\": \"Period 1\", \"start\": -1, \"duration\": 8, \"daylabels\": [-1, 1, 2, 3, 6, 7], \"dayshading\": [1, 7] } ] } Note Wherever lists of days are expected as the input to a field, there are different options. In the simplest case, a list of day numbers can be provided: [-1, 1, 2, 3, 5, 7] If subsequent days are to be specified, it may be more convenient to use a range format. Note that ranges need to be provided with enclosing double quotes. Individual days and ranges can be combined: [-1, \"1-3\", 5, 7]","title":"Period formatting"},{"location":"input/#period-elements","text":"To every period , elements can be appended. There are three classes of elements: intervals , administrations and procedures . Individual elements of these classes must be given as a list of the respective types (see examples below). This results in a hierarchical structure of the input file where lists can have members that themselves may contain lists of child elements. To better visualize the hierarchy, successive indentation levels are used in the json blocks shown in this documentation. Note that this is not a strict requirement for the json-formatted input file, however it is considered good practice. The three element classes have different visual representations and may have different property fields. The following gives an overview on this.","title":"Period elements"},{"location":"input/#intervals","text":"Intervals are typically used to denote hospitalization phases or ambulatory visits, and are represented in the output as boxes spanning the respective days. There are two different ways of specifying intervals: For intervals that span multiple days, a start and duration must be given. For single-day intervals, a list of days can be given instead. The duration is then assumed to be one day. A valid example may look like this: { \"periods\": [ { \"caption\": \"Period 1\", \"start\": -1, \"duration\": 10, \"daylabels\": [-1, \"1-9\"], \"intervals\": [ { \"caption\": \"hospitalization\", \"start\": -1, \"duration\": 4 }, { \"caption\": \"ambulatory visit\", \"days\": [5, 7, 9] } ] } ] }","title":"Intervals"},{"location":"input/#administrations","text":"IMP administrations are shown in the output using arrow symbols. The minimally required fields are caption and days . As mentioned above , days is expected to be a list of numbers or double-quoted day ranges. Both are used in the below example: { \"periods\": [ { \"caption\": \"Period 1\", \"start\": -1, \"duration\": 10, \"daylabels\": [-1, \"1-9\"], \"administrations\": [ { \"caption\": \"aspirin\", \"days\": [1] }, { \"caption\": \"paracetamole\", \"days\": [5, 6, 7] } ] }, { \"caption\": \"Period 2\", \"start\": 10, \"duration\": 4, \"daylabels\": [\"10-14\"], \"administrations\": [ { \"caption\": \"aspirin\", \"days\": [11] } ] } ] }","title":"Administrations"},{"location":"input/#procedures","text":"All other study assessments (e.g., blood sampling, ECG, etc.) are specified as procedures . In general, study procedures may be conducted once per day or multiple times per day. In the graphical representation, the respective symbols are diamonds and boxes. The frequency of a procedure can be specified using the freq field: \"QD\" indicates once daily, while \"rich\" indicates multiple daily time points. For \"QD\", the freq field can also be omitted (e.g., for the ECG on day 5, below). { \"periods\": [ { \"caption\": \"Period 1\", \"start\": -1, \"duration\": 8, \"daylabels\": [-1, \"1-7\"], \"procedures\": [ { \"caption\": \"ECG\", \"days\": [-1], \"freq\": \"QD\" }, { \"caption\": \"ECG\", \"days\": [5] }, { \"caption\": \"ECG\", \"days\": [7], \"freq\": \"rich\" } ] } ] }","title":"Procedures"},{"location":"input/#advanced-notation","text":"","title":"Advanced notation"},{"location":"input/#exact-procedure-times","text":"As a more granular alternative to the rather coarse definition of the procedure frequency using the freq field, precise preocedure times can be noted for procedures, e.g., for PK samplings. The times (in hours) is to be provided as a list to the times field. In addition, a relative field must be provided to clearly indicate to which day the times refer: { \"periods\": [ { \"caption\": \"Period 1\", \"start\": -1, \"duration\": 8, \"daylabels\": [-1, \"1-7\"], \"procedures\": [ { \"caption\": \"ECG\", \"days\": [1], \"times\": [0, 0.5, 1, 2, 4, 6, 8, 12, 24, 36, 48], \"relative\": 1 } ] } ] } This notation automatically assigns the right symbols for the days onto which the time points fall. In the above example, the time point list indicates that there are multiple time points on days 1 and 2 (leading to a box symbol for these days) but a single time point on day 2 (diamond symbol): Sometimes, it is desirable to print a more detailed timeline for a procedure (e.g., to show the PK sampling schedule). This can be achieved by adding a timescale field with the value \"show\". In addition, as described on the Use page, the commandline parameter --timescale (or short -t ) must be set to achieve this. { \"periods\": [ { \"caption\": \"Period 1\", \"start\": -1, \"duration\": 8, \"daylabels\": [-1, \"1-7\"], \"procedures\": [ { \"caption\": \"PK sampling\", \"days\": [1], \"times\": [0, 0.5, 1, 2, 4, 6, 8, 12, 24, 36, 48], \"relative\": 1, \"timescale\": \"show\" } ] } ] } (Created by invoking: python td.py -t sample.jpg )","title":"Exact procedure times"},{"location":"input/#exact-dose-information","text":"In some cases, the dose for an IMP changes over time in a scheduled way, e.g. to phase in or out a sensitive drug. In this cases, the respective administration element can include specific dosing information using a numerical dose field. The below example shows a dose escalation for carbamazepine: \"administrations\": [ { \"caption\": \"carbamazepine BID\", \"days\": [\"8-9\"], \"dose\": 100 }, { \"caption\": \"carbamazepine BID\", \"days\": [\"10-11\"], \"dose\": 200 }, { \"caption\": \"carbamazepine BID\", \"days\": [\"12-32\"], \"dose\": 300 } ] As detailed on the Use page, a dose graph can then be displayed in the output to indicate the dose over time using the \"--graph\" (or \"-g\") option.","title":"Exact dose information"},{"location":"input/#other-procedure-symbols","text":"In cases where prodecure symbols should indicate different conditions (e.g., fasted vs. fed), a value field can be included in the procedure element. Procedures with a value field are not shown as diamonds but as hollow circles if the value is zero, and filled circles for any value other than zero: { \"periods\": [ { \"caption\": \"Period 1\", \"start\": -1, \"duration\": 8, \"daylabels\": [-1, \"1-7\"], \"procedures\": [ { \"caption\": \"food\", \"days\": [1], \"value\": 0 }, { \"caption\": \"food\", \"days\": [5], \"value\": 1 } ] } ] }","title":"Other procedure symbols"},{"location":"input/#period-highlighting","text":"To visually make a period stand out, the period element can include a decoration field. Possible values are \"highlighted\" for a shaded background or \"bracketed\" to indicate, e.g., optional periods. Setting the value to \"none\" removes the effect, this can be used for quick testing purposes. { \"periods\": [ { \"caption\": \"Period 1\", \"start\": -1, \"duration\": 5, \"daylabels\": [-1, \"1-4\"], \"decoration\": \"highlighted\", \"procedures\": [ { \"caption\": \"massage\", \"days\": [\"1-2\"] } ] }, { \"caption\": \"Period 2\", \"start\": 1, \"duration\": 4, \"daylabels\": [\"1-4\"], \"procedures\": [ { \"caption\": \"massage\", \"days\": [\"1-2\"] } ] }, { \"caption\": \"Period 3\", \"start\": 1, \"duration\": 4, \"daylabels\": [\"1-4\"], \"decoration\": \"bracketed\", \"procedures\": [ { \"caption\": \"massage\", \"days\": [ \"1-2\"] } ] } ] }","title":"Period highlighting"},{"location":"input/#procedure-labels","text":"To annotate individual procedure instances, e.g., to give visits a unique identifier (see below) or to add details to a procedure on a certain day, the labels field can be added to a procedure. Its value is expected to be a list of labels corresponding to the list of days of that procedure. Labels are rendered in the output above the respective days. Lables can be added to intervals, administrations or procedures. Note: If the procedure is an interval that is defined using start and duration , that list is expected to contain only one label which is then displayed above the start day of the interval: { \"periods\": [ { \"caption\": \"Period 1\", \"start\": -1, \"duration\": 10, \"daylabels\": [-1, \"1-9\"], \"intervals\": [ { \"caption\": \"hospitalization\", \"start\": -1, \"duration\": 4, \"labels\": [\"V1\"] }, { \"caption\": \"ambulatory visit\", \"days\": [5, 7, 9], \"labels\": [\"V2\", \"V3\", \"V4\"] } ] } ] }","title":"Procedure labels"},{"location":"input/#footnotes","text":"Footnotes can be added to any interval , administration or procedure field, defining an entry footnotes that has a list as its value. The elements of that list need to have days , symbol and text entires that define the days to be annotated, the footnote symbol to be rendered above it, and the full text that is rendered at the bottom of the output. Footnote symbols can be re-used in other procedures. the text field in further copies is expected to be an empty string (i.e., \"\"). Note that in the output, footnotes are only rendered if specified explicitly with the \"--footnote\" (or \"-n\") option (see Use ). The below figure was created by invoking python td.py -n sample.jpg : { \"periods\": [ { \"caption\": \"Periods 1-3\", \"start\": -1, \"duration\": 8, \"daylabels\": [-1, \"1-7\"], \"procedures\": [ { \"caption\": \"ECG\", \"days\": [ 1, 2, 3, 7], \"footnotes\": [ { \"days\": [2, 7], \"symbol\": \"a\", \"text\": \"Period 1 only\" }, { \"days\": 7, \"symbol\": \"b\", \"text\": \"Before discharge\" } ] }, { \"caption\": \"vital signs\", \"days\": [-1, 5, 7], \"footnotes\": [ { \"days\": 5, \"symbol\": \"a\", \"text\": \"\" } ] } ] } ] }","title":"Footnotes"},{"location":"td/","text":"Functions activity_days ( period ) returns a list of boolean values per day to indicate whether there are procedures on the day Source code in trialdesign/td.py def activity_days ( period ): \"\"\"returns a list of boolean values per day to indicate whether there are procedures on the day\"\"\" start = period [ \"start\" ] duration = period [ \"duration\" ] if start < 0 and start + duration > 0 : duration += 1 # start and end of period, start and end of trains of procedure days out = [ start , start + duration - 1 ] for x in [ \"administrations\" , \"procedures\" ]: if x in period . keys (): for i in period [ x ]: if \"days\" in i . keys (): temp = decode_daylist ( i [ \"days\" ]) out += extract_start_end ( temp ) # all PK days if \"procedures\" in period . keys (): for i in period [ \"procedures\" ]: if \"times\" in i : out += [ d for ( d , t , r ) in normalize_procedure ( extract_procedure ( period , i [ \"caption\" ]))] if \"intervals\" in period . keys (): for i in period [ \"intervals\" ]: if \"start\" in i . keys () and \"duration\" in i . keys (): start = i [ \"start\" ] duration = i [ \"duration\" ] if start < 0 and start + duration > 0 : duration += 1 temp = list ( range ( start , start + duration )) if 0 in temp : temp . remove ( 0 ) out += extract_start_end ( temp ) out . sort () temp = [ False ] * period [ 'duration' ] for i in list ( dict . fromkeys ( out )): temp [ day_index ( period , i )] = True return ( temp ) add_output ( old , new ) add output of render functions Source code in trialdesign/td.py def add_output ( old , new ): \"\"\"add output of render functions\"\"\" return ([ o + n for o , n in zip ( old , new )]) day_index ( period , day ) convert day to index within daylist Source code in trialdesign/td.py def day_index ( period , day ): \"\"\"convert day to index within daylist\"\"\" temp = day - period [ 'start' ] if period [ 'start' ] < 0 and day > 0 : temp -= 1 # correct for absent day 0 if temp < 0 or temp > period [ \"duration\" ] - 1 : raise IndexError ( f 'day index { day } out of range ( { period [ \"start\" ] } to { period [ \"start\" ] + period [ \"duration\" ] } )' ) return ( temp ) decode_daylist ( daylist ) convert 'days' field (including day ranges) to list of individual days Parameters: daylist: list of period days, either in numerical format (e.g., -1, 1, 2), or as strings that may represent single days (e.g., \"-1\", \"1\") or day ranges (e.g., \"1-3\"). Day ranges can also include multiple segments (e.g., \"1-3, 5-7\", \"1-3, 4, 5\") Source code in trialdesign/td.py def decode_daylist ( daylist ): \"\"\"convert 'days' field (including day ranges) to list of individual days Arguments: daylist: list of period days, either in numerical format (e.g., -1, 1, 2), or as strings that may represent single days (e.g., \"-1\", \"1\") or day ranges (e.g., \"1-3\"). Day ranges can also include multiple segments (e.g., \"1-3, 5-7\", \"1-3, 4, 5\") \"\"\" days = [] if not isinstance ( daylist , list ): daylist = [ daylist ] for i in daylist : if isinstance ( i , int ): days . append ( i ) elif isinstance ( i , str ): pat_element = r '(\\d+)(-(\\d+))?' pat = f '( { pat_element } (, )*)' m = re . findall ( pat , i ) if m : for mm in m : if mm [ 3 ] == \"\" : days . append ( int ( mm [ 1 ])) else : for i in range ( int ( mm [ 1 ]), int ( mm [ 3 ]) + 1 ): days . append ( i ) return ( days ) extract_footnotes ( period , caption ) extract footnotes for procedures by day, if applicable Source code in trialdesign/td.py def extract_footnotes ( period , caption ): \"\"\"extract footnotes for procedures by day, if applicable\"\"\" out = [[ False ] * period [ 'duration' ], [ '' ] * period [ 'duration' ], []] def temp ( proc , out ): if 'footnotes' in proc . keys (): for f in proc [ \"footnotes\" ]: if not \"days\" in f . keys (): raise KeyError ( f 'no \"days\" in footnote \" { f [ \"text\" ] } \"' ) else : if not isinstance ( f [ \"days\" ], list ): daylist = [ f [ \"days\" ]] else : daylist = f [ \"days\" ] for d in decode_daylist ( daylist ): i = day_index ( period , d ) out [ 0 ][ i ] = True if out [ 1 ][ i ]: out [ 1 ][ i ] += \",\" out [ 1 ][ i ] += str ( f [ 'symbol' ]) out [ 2 ] . append ([ f [ 'symbol' ], f [ 'text' ]]) return ( out ) return ( iterate_over_procedures ( period , caption , out , temp )) extract_procedure ( period , caption ) get specified administration/procedure as list of tuples (day, [times], relative) for individual days Source code in trialdesign/td.py def extract_procedure ( period , caption ): \"\"\"get specified administration/procedure as list of tuples (day, [times], relative) for individual days\"\"\" out = [] def temp ( proc , out ): if 'times' in proc . keys (): t = proc [ 'times' ] elif 'freq' in proc . keys () and proc [ 'freq' ] == 'rich' : t = [ 0 , 0 ] else : t = [ 0 ] if 'relative' in proc . keys (): rel = proc [ 'relative' ] else : rel = 1 out += [( d , t , rel ) for d in decode_daylist ( proc [ 'days' ])] return ( out ) return ( iterate_over_procedures ( period , caption , out , temp )) extract_start_end ( daylist ) from day list, extract start and end days of trains of days Source code in trialdesign/td.py def extract_start_end ( daylist ): \"\"\"from day list, extract start and end days of trains of days\"\"\" last_day = 0 out = [] if daylist : daylist . sort () for i in daylist : if i == daylist [ 0 ] or i != last_day + 1 and not ( last_day == - 1 and i == 1 ): out += [ last_day , i ] last_day = i out += [ i ] out = list ( dict . fromkeys ( out )) if 0 in out : out . remove ( 0 ) return ( out ) has_timescale ( period , caption ) test if procedure has timescale in the respective period Source code in trialdesign/td.py def has_timescale ( period , caption ): \"\"\"test if procedure has timescale in the respective period\"\"\" out = [] def temp ( proc , out ): if 'timescale' in proc . keys (): if proc [ 'timescale' ] == 'show' : out . append ( True ) return ( out ) return ( True in iterate_over_procedures ( period , caption , out , temp )) item_names ( periods , item_class ) return list of interval/administration/procedure names for trial Source code in trialdesign/td.py def item_names ( periods , item_class ): \"\"\"return list of interval/administration/procedure names for trial\"\"\" out = [] for p in periods : if item_class in p . keys (): for proc in p [ item_class ]: temp = proc [ 'caption' ] if not temp in out : out . append ( temp ) return ( out ) normalize_procedure ( procedure ) break down procedure times to subsequent days, if longer than 24 h Source code in trialdesign/td.py def normalize_procedure ( procedure ): \"\"\"break down procedure times to subsequent days, if longer than 24 h\"\"\" out = [] for ( d , t , rel ) in procedure : dd = 0 while t : temp = [ i for i in t if i < 24 ] if temp : out . append (( d + dd , temp , rel )) t = [ i - 24 for i in t if i >= 24 ] dd += 1 return ( out ) period_day_centers ( period , xoffset , daywidth_function ) return list of x-coordinates for day centers Source code in trialdesign/td.py def period_day_centers ( period , xoffset , daywidth_function ): \"\"\"return list of x-coordinates for day centers\"\"\" return ([ start + width / 2 for start , width in zip ( period_day_starts ( period , xoffset , daywidth_function ), daywidth_function ( period ))]) period_day_ends ( period , xoffset , daywidth_function ) return list of x-coordinates for day ends Source code in trialdesign/td.py def period_day_ends ( period , xoffset , daywidth_function ): \"\"\"return list of x-coordinates for day ends\"\"\" starts = period_day_starts ( period , xoffset , daywidth_function ) widths = daywidth_function ( period ) return ([ s + w for s , w in zip ( starts , widths )]) period_day_starts ( period , xoffset , daywidth_function ) return list of x-coordinates for day starts Source code in trialdesign/td.py def period_day_starts ( period , xoffset , daywidth_function ): \"\"\"return list of x-coordinates for day starts\"\"\" out = [ xoffset ] acc = xoffset for i in daywidth_function ( period ): acc += i out . append ( acc ) return out [: - 1 ] render_daygrid ( period , caption , xoffset , yoffset , height , metrics , style , first_pass = True ) render svg output for the day grid for a period. Output is [svg_output, height] Source code in trialdesign/td.py def render_daygrid ( period , caption , xoffset , yoffset , height , metrics , style , first_pass = True ): \"\"\"render svg output for the day grid for a period. Output is [svg_output, height]\"\"\" ( daywidth_function , textwidth_function , textheight_function ) = metrics ( periodspacing , lineheight , ypadding , lwd , ellipsis , debug ) = style svg_out = \"\" y = yoffset if debug : svg_out += render_dummy ( period , xoffset , yoffset , height , metrics ) for start , width , center , label , shading in zip ( period_day_starts ( period , xoffset , daywidth_function ), daywidth_function ( period ), period_day_centers ( period , xoffset , daywidth_function ), day_labels ( period ), day_shadings ( period )): if shading : svg_out += svg_rect ( start , y , width , height , lwd = 0 , fill_color = \"lightgray\" ) if width > textwidth_function ( \"XX\" ) / 3 : svg_out += svg_rect ( start , y , width , height , lwd = lwd ) else : svg_out += svg_line ( start , y , start + width , y , lwd = lwd , dashed = True ) svg_out += svg_line ( start , y + height , start + width , y + height , lwd = lwd , dashed = True ) label = str ( label ) delta = textwidth_function ( \"1\" ) * .5 if label and label [ 0 ] == \"1\" else 0 if width > textwidth_function ( str ( label )): svg_out += svg_text ( center - textwidth_function ( str ( label )) / 2 - delta , yoffset + height - ( height - textheight_function ( \"X\" )) / 2 , str ( label )) return ([ svg_out , height + ypadding * 2 ]) render_dose_graph ( period , caption , xoffset , yoffset , lineheight , metrics , style , first_pass = True ) render dose over time for administration. Output is [svg_output, height] Source code in trialdesign/td.py def render_dose_graph ( period , caption , xoffset , yoffset , lineheight , metrics , style , first_pass = True ): \"\"\"render dose over time for administration. Output is [svg_output, height]\"\"\" ( daywidth_function , textwidth_function , textheight_function ) = metrics ( periodspacing , lineheight , ypadding , lwd , ellipsis , debug ) = style svg_out = \"\" if debug : svg_out += render_dummy ( period , xoffset , yoffset , lineheight + textheight_function ( \"X\" ), metrics ) startx = period_day_starts ( period , xoffset , daywidth_function ) endx = period_day_ends ( period , xoffset , daywidth_function ) doses = [ i for i in extract_field ( period , caption , \"dose\" )] doses_num = [ i for i in doses if isinstance ( i , int ) or isinstance ( i , float )] if len ( doses_num ): maxdose , mindose = max ( doses_num ), min ( doses_num ) def dosey ( dose ): return ( yoffset + lineheight * 0.6 - ( dose - mindose ) / ( maxdose - mindose ) * lineheight * 0.6 ) # if doses: lastx , lasty , lastdose = 0 , 0 , 0 lastend = 0 for ( s , e , d ) in zip ( startx , endx , doses ): if type ( d ) == int or type ( d ) == float : svg_out += svg_line ( s , dosey ( d ), e , dosey ( d ), lwd = lwd ) if lasty : svg_out += svg_line ( lastx , lasty , s , dosey ( d ), lwd = lwd ) lastx , lasty = e , dosey ( d ) if d != lastdose : if lastend + textwidth_function ( \"n\" ) < s : svg_out += svg_text ( s , yoffset + lineheight + textheight_function ( \"X\" ), str ( d )) lastend = s + textwidth_function ( str ( d )) lastdose = d return ([ svg_out , lineheight + textheight_function ( \"X\" ) + ypadding ]) render_dummy ( period , xoffset , yoffset , lineheight , metrics ) render bounding box for visual debugging purposes. Output is svg code only. Source code in trialdesign/td.py def render_dummy ( period , xoffset , yoffset , lineheight , metrics ): \"\"\"render bounding box for visual debugging purposes. Output is svg code only.\"\"\" daywidth_function = metrics [ 0 ] return ( svg_rect ( xoffset , yoffset , period_width ( period , daywidth_function ), lineheight , lwd = 0 , fill_color = \"cornsilk\" )) render_interval ( period , caption , xoffset , yoffset , lineheight , metrics , style , first_pass = True ) render interval for procedure. Output is [svg_output, height] Source code in trialdesign/td.py def render_interval ( period , caption , xoffset , yoffset , lineheight , metrics , style , first_pass = True ): \"\"\"render interval for procedure. Output is [svg_output, height]\"\"\" ( daywidth_function , textwidth_function , textheight_function ) = metrics ( periodspacing , lineheight , ypadding , lwd , ellipsis , debug ) = style svg_out = \"\" y = yoffset + lineheight / 2 if debug : svg_out += render_dummy ( period , xoffset , yoffset , lineheight , metrics ) if first_pass : svg_out += svg_text ( 5 , y + textheight_function ( caption ) * ( 1 / 2 - 0.1 ), caption ) # render interval box starts = period_day_starts ( period , xoffset , daywidth_function ) ends = period_day_ends ( period , xoffset , daywidth_function ) widths = daywidth_function ( period ) height = 0.4 * lineheight if 'intervals' in period . keys (): for intv in period [ 'intervals' ]: if intv [ 'caption' ] == caption : if \"start\" in intv . keys () and \"duration\" in intv . keys (): start_list , duration_list = [ intv [ 'start' ]], [ intv [ 'duration' ]] elif \"days\" in intv . keys () and isinstance ( intv [ \"days\" ], list ): start_list = decode_daylist ( intv [ \"days\" ]) duration_list = [ 1 for i in decode_daylist ( intv [ \"days\" ])] else : raise TypeError ( f ' { period [ \"caption\" ] } , interval \" { intv [ \"caption\" ] } \"' ) for start , duration in zip ( start_list , duration_list ): startx = starts [ day_index ( period , start )] end = start + duration - 1 if start < 0 and end > 0 : end += 1 endx = ends [ day_index ( period , end )] if \"decoration\" in intv . keys (): if intv [ \"decoration\" ] == \"bracketed\" : wo = widths [ day_index ( period , start )] wc = widths [ day_index ( period , end )] svg_out += svg_open_bracket ( startx , y , lineheight , wo * .6 , xpadding = 0 , radius = lineheight / 8 , lwd = lwd ) svg_out += svg_close_bracket ( endx , y , lineheight , wc * .6 , xpadding = 0 , radius = lineheight / 8 , lwd = lwd ) svg_out += svg_rect ( startx , y - height / 2 , endx - startx , height , lwd = lwd ) return ([ svg_out , lineheight + ypadding ]) render_periodcaption ( period , caption , xoffset , yoffset , height , metrics , style , first_pass = True ) render caption for period. The 'caption' input is ignored and the caption field of the input period is used. Output is [svg_output, height] Source code in trialdesign/td.py def render_periodcaption ( period , caption , xoffset , yoffset , height , metrics , style , first_pass = True ): \"\"\"render caption for period. The 'caption' input is ignored and the caption field of the input period is used. Output is [svg_output, height]\"\"\" ( daywidth_function , textwidth_function , textheight_function ) = metrics ( periodspacing , lineheight , ypadding , lwd , ellipsis , debug ) = style svg_out = \"\" if debug : svg_out += render_dummy ( period , xoffset , yoffset , height , metrics ) xcenter = xoffset + period_width ( period , daywidth_function ) / 2 svg_out += svg_text ( xcenter - textwidth_function ( str ( period [ 'caption' ])) / 2 , yoffset + height - ( height - textheight_function ( \"X\" )) / 2 , str ( period [ 'caption' ])) return ([ svg_out , height + ypadding / 2 ]) render_periods ( periods , x , y , caption , height , render_function , metrics , style , dashes = False , footnotes = False , ** kwargs ) applies rendering function to all periods Source code in trialdesign/td.py def render_periods ( periods , x , y , caption , height , render_function , metrics , style , dashes = False , footnotes = False , ** kwargs ): \"\"\"applies rendering function to all periods\"\"\" daywidth_function = metrics [ 0 ] ( periodspacing , lineheight , ypadding , lwd , ellipsis , debug ) = style w = [ period_width ( i , daywidth_function ) for i in periods ] first = True last = False h = 0 out = \"\" # render labels, if applicable has_labels = len ([ i for ii in [ extract_labels ( p , caption ) for p in periods ] for i in ii if i != '' ]) != 0 has_footnotes = True in [ i for ii in [ extract_footnotes ( p , caption )[ 0 ] for p in periods ] for i in ii ] if not footnotes : has_footnotes = False if has_labels or has_footnotes : xx = x for p in periods : [ svg_out , y_out ] = render_labels_footnotes ( p , caption , xx , y , height , metrics , style , footnotes = footnotes ) out += svg_out xx += period_width ( p , daywidth_function ) + periodspacing h += lineheight y += h # render procedure for p in periods : if p == periods [ - 1 ]: last = True [ svg_out , y_out ] = render_function ( p , caption , x , y , height , metrics , style , first_pass = first , ** kwargs ) out += svg_out if dashes and not last : out += svg_line ( x + period_width ( p , daywidth_function ), y + height / 2 , x + period_width ( p , daywidth_function ) + periodspacing , y + height / 2 , lwd = lwd ) x += period_width ( p , daywidth_function ) + periodspacing first = False return ( add_output ([ \"\" , h ], [ out , y_out ])) render_procedure ( period , caption , xoffset , yoffset , lineheight , metrics , style , default_symbol = 'diamond' , first_pass = True ) render procedure. Output is [svg_output, height] Source code in trialdesign/td.py def render_procedure ( period , caption , xoffset , yoffset , lineheight , metrics , style , default_symbol = \"diamond\" , first_pass = True ): \"\"\"render procedure. Output is [svg_output, height]\"\"\" ( daywidth_function , textwidth_function , textheight_function ) = metrics ( periodspacing , lineheight , ypadding , lwd , ellipsis , debug ) = style svg_out = \"\" if debug : svg_out += render_dummy ( period , xoffset , yoffset , lineheight , metrics ) y = yoffset + lineheight / 2 # center of the line if first_pass : svg_out += svg_text ( 5 , y + textheight_function ( caption ) * ( 1 / 2 - 0.1 ), caption ) centers = period_day_centers ( period , xoffset , daywidth_function ) widths = daywidth_function ( period ) brackets = extract_field ( period , caption , \"decoration\" ) symbols = procedure_symbols ( period , caption , default_symbol ) dlabels = day_labels ( period ) values = extract_field ( period , caption , \"value\" ) ellipses = [ 1 if ( s != \"\" and l == \"\" and len ( symbols ) > 3 ) else 0 for ( s , l ) in zip ( symbols , dlabels )] for p , w , s , b , e , v in zip ( centers , widths , symbols , brackets , ellipses , values ): if s : if e == 1 and b == \"\" and ellipsis : svg_out += svg_circle ( p , y , lineheight / 30 , fill_color = \"black\" ) elif v != \"\" : if v == 0 : svg_out += svg_symbol ( p , y , w * .5 , \"circle\" , fill = False , fill_color = \"none\" , lwd = lwd ) else : svg_out += svg_symbol ( p , y , w * .5 , \"circle\" , fill = True , fill_color = \"black\" ) else : svg_out += svg_symbol ( p , y , w , s , size = textheight_function ( \"X\" ), lwd = lwd , title = caption ) if b == \"bracketed\" : svg_out += svg_open_bracket ( p , y , lineheight , w * .8 , xpadding = 0 , radius = lineheight / 8 , lwd = lwd ) svg_out += svg_close_bracket ( p , y , lineheight , w * .8 , xpadding = 0 , radius = lineheight / 8 , lwd = lwd ) return ([ svg_out , lineheight + ypadding ]) render_times ( period , caption , xoffset , yoffset , lineheight , metrics , style , maxwidth = 100 ) render timescale for procedure. Output is [svg_output, height] Source code in trialdesign/td.py def render_times ( period , caption , xoffset , yoffset , lineheight , metrics , style , maxwidth = 100 ): \"\"\"render timescale for procedure. Output is [svg_output, height]\"\"\" ( daywidth_function , textwidth_function , textheight_function ) = metrics ( periodspacing , lineheight , ypadding , lwd , ellipsis , debug ) = style out = \"\" proc = normalize_procedure ( extract_procedure ( period , caption )) ts_days = [] for x in [ 'procedures' , 'administrations' ]: if x in period . keys (): for p in period [ x ]: if p [ 'caption' ] == caption : if \"timescale\" in p . keys () and p [ \"timescale\" ] == \"show\" : ts_days . append ( p [ \"relative\" ]) ts_days = set ( ts_days ) y = yoffset bracketheight = lineheight * 2 / 3 last_scale_end = 0 if ts_days : ## curly brackets if debug : out += render_dummy ( period , xoffset , y , bracketheight , metrics ) for ts_d in ts_days : times = unnormalize_procedure ([ i for i in proc if i [ 2 ] == ts_d ])[ 0 ][ 1 ] startx = period_day_starts ( period , xoffset , daywidth_function )[ day_index ( period , min ([ i for ( i , t , rel ) in proc if rel == ts_d ]))] endx = period_day_ends ( period , xoffset , daywidth_function )[ day_index ( period , max ([ i for ( i , t , rel ) in proc if rel == ts_d ]))] radius = bracketheight / 2 if radius * 4 > endx - startx : startx -= radius / 2 endx += radius / 2 radius = ( endx - startx ) / 5 out += svg_curly_up ( startx , endx , y , radius = radius , lwd = lwd ) y += bracketheight + ypadding * 1.5 ## timescales if debug : out += render_dummy ( period , xoffset , y , lineheight * 1.33 + ypadding * 2 + textheight_function ( \"X\" ), metrics ) for ts_d in ts_days : times = unnormalize_procedure ([ i for i in proc if i [ 2 ] == ts_d ])[ 0 ][ 1 ] maxtime = max ( times ) break_time = min ( sorted ( list ([ i for i in times if i < 24 ]))[ - 1 ] + 2 , 23 ) times_below = len ([ i for i in times if i <= break_time ]) times_above = len ([ i for i in times if i > break_time ]) startx = period_day_starts ( period , xoffset , daywidth_function )[ day_index ( period , min ([ i for ( i , t , rel ) in proc if rel == ts_d ]))] ### scale scale_height = lineheight / 3 scale_width = min ( len ( times ) * textwidth_function ( \"XX\" ), maxwidth - xoffset ) scale_break = scale_width * times_below / ( times_below + times_above ) scale_gap = textwidth_function ( \"m\" ) scale_startx = max ( min ( startx , xoffset + period_width ( period , daywidth_function ) - scale_width ), xoffset ) if scale_startx < last_scale_end : y += lineheight * 1.33 + ypadding * 3 + textheight_function ( \"X\" ) def render_scale ( x , y , width , height , scale_min , scale_max , scale_labels , show_unit = False ): out = svg_line ( x , y , x + width , y , lwd = lwd ) label_widths = [ textwidth_function ( str ( i )) for i in scale_labels ] last_label_end = 0 final_label_begin = x + width - label_widths [ - 1 ] / 2 min_delta = textwidth_function ( \".\" ) for i , wi in zip ( scale_labels , label_widths ): xi = ( i - scale_min ) * width / ( scale_max - scale_min ) + x out += svg_line ( xi , y - height / 2 , xi , y + height / 2 , lwd = lwd ) dxi = wi / 2 if xi - dxi > last_label_end and xi + dxi < final_label_begin - min_delta : out += svg_text ( xi - dxi , y + height / 2 + textheight_function ( \"X\" ) + ypadding , str ( i )) last_label_end = xi + dxi + min_delta if i == scale_labels [ - 1 ]: temp = str ( i ) if show_unit : temp += \" h\" out += svg_text ( xi - dxi , y + height / 2 + textheight_function ( \"X\" ) + ypadding , temp ) return ( out ) def render_points ( x , y , width , scale_min , scale_max ): points = [ t for t in times if t >= scale_min and t <= scale_max ] points_x = [( i - scale_min ) * width / ( scale_max - scale_min ) + x for i in points ] out = \"\" for p , xi in zip ( points , points_x ): out += svg_symbol ( xi , y + lineheight / 2 , 0 , \"diamond\" , size = textheight_function ( \"X\" ), lwd = lwd ) return ( out ) out += render_points ( scale_startx , y , scale_break , 0 , break_time ) out += render_points ( scale_startx + scale_break + scale_gap , y , scale_width - scale_gap - scale_break , 24 , max ( maxtime , 36 )) out += render_scale ( scale_startx , y + lineheight + ypadding , scale_break , scale_height , 0 , break_time , range ( 0 , int ( break_time ), 2 )) if maxtime >= 24 : out += render_scale ( scale_startx + scale_break + scale_gap , y + lineheight + ypadding , scale_width - scale_gap - scale_break , scale_height , 24 , max ( maxtime , 36 ), [ i * 24 for i in range ( 1 , int ( maxtime / 24 + 1 ))], show_unit = True ) last_scale_end = scale_startx + scale_width return ([ out , y + lineheight * 1.33 + ypadding * 3 + textheight_function ( \"X\" ) - yoffset ]) unnormalize_procedure ( procedure ) collate procedure times into single day, if relative to the same day Source code in trialdesign/td.py def unnormalize_procedure ( procedure ): \"\"\" collate procedure times into single day, if relative to the same day\"\"\" out = [] if procedure : rels = set ([ r for ( d , ts , r ) in procedure ]) for rel in rels : current_times = [] for ( d , ts , r ) in procedure : for t in ts : if r == rel : current_times . append ( t + ( d - r ) * 24 ) out . append (( rel , current_times , rel )) return ( out )","title":"Code documentation"},{"location":"td/#functions","text":"","title":"Functions"},{"location":"td/#td.activity_days","text":"returns a list of boolean values per day to indicate whether there are procedures on the day Source code in trialdesign/td.py def activity_days ( period ): \"\"\"returns a list of boolean values per day to indicate whether there are procedures on the day\"\"\" start = period [ \"start\" ] duration = period [ \"duration\" ] if start < 0 and start + duration > 0 : duration += 1 # start and end of period, start and end of trains of procedure days out = [ start , start + duration - 1 ] for x in [ \"administrations\" , \"procedures\" ]: if x in period . keys (): for i in period [ x ]: if \"days\" in i . keys (): temp = decode_daylist ( i [ \"days\" ]) out += extract_start_end ( temp ) # all PK days if \"procedures\" in period . keys (): for i in period [ \"procedures\" ]: if \"times\" in i : out += [ d for ( d , t , r ) in normalize_procedure ( extract_procedure ( period , i [ \"caption\" ]))] if \"intervals\" in period . keys (): for i in period [ \"intervals\" ]: if \"start\" in i . keys () and \"duration\" in i . keys (): start = i [ \"start\" ] duration = i [ \"duration\" ] if start < 0 and start + duration > 0 : duration += 1 temp = list ( range ( start , start + duration )) if 0 in temp : temp . remove ( 0 ) out += extract_start_end ( temp ) out . sort () temp = [ False ] * period [ 'duration' ] for i in list ( dict . fromkeys ( out )): temp [ day_index ( period , i )] = True return ( temp )","title":"activity_days()"},{"location":"td/#td.add_output","text":"add output of render functions Source code in trialdesign/td.py def add_output ( old , new ): \"\"\"add output of render functions\"\"\" return ([ o + n for o , n in zip ( old , new )])","title":"add_output()"},{"location":"td/#td.day_index","text":"convert day to index within daylist Source code in trialdesign/td.py def day_index ( period , day ): \"\"\"convert day to index within daylist\"\"\" temp = day - period [ 'start' ] if period [ 'start' ] < 0 and day > 0 : temp -= 1 # correct for absent day 0 if temp < 0 or temp > period [ \"duration\" ] - 1 : raise IndexError ( f 'day index { day } out of range ( { period [ \"start\" ] } to { period [ \"start\" ] + period [ \"duration\" ] } )' ) return ( temp )","title":"day_index()"},{"location":"td/#td.decode_daylist","text":"convert 'days' field (including day ranges) to list of individual days Parameters: daylist: list of period days, either in numerical format (e.g., -1, 1, 2), or as strings that may represent single days (e.g., \"-1\", \"1\") or day ranges (e.g., \"1-3\"). Day ranges can also include multiple segments (e.g., \"1-3, 5-7\", \"1-3, 4, 5\") Source code in trialdesign/td.py def decode_daylist ( daylist ): \"\"\"convert 'days' field (including day ranges) to list of individual days Arguments: daylist: list of period days, either in numerical format (e.g., -1, 1, 2), or as strings that may represent single days (e.g., \"-1\", \"1\") or day ranges (e.g., \"1-3\"). Day ranges can also include multiple segments (e.g., \"1-3, 5-7\", \"1-3, 4, 5\") \"\"\" days = [] if not isinstance ( daylist , list ): daylist = [ daylist ] for i in daylist : if isinstance ( i , int ): days . append ( i ) elif isinstance ( i , str ): pat_element = r '(\\d+)(-(\\d+))?' pat = f '( { pat_element } (, )*)' m = re . findall ( pat , i ) if m : for mm in m : if mm [ 3 ] == \"\" : days . append ( int ( mm [ 1 ])) else : for i in range ( int ( mm [ 1 ]), int ( mm [ 3 ]) + 1 ): days . append ( i ) return ( days )","title":"decode_daylist()"},{"location":"td/#td.extract_footnotes","text":"extract footnotes for procedures by day, if applicable Source code in trialdesign/td.py def extract_footnotes ( period , caption ): \"\"\"extract footnotes for procedures by day, if applicable\"\"\" out = [[ False ] * period [ 'duration' ], [ '' ] * period [ 'duration' ], []] def temp ( proc , out ): if 'footnotes' in proc . keys (): for f in proc [ \"footnotes\" ]: if not \"days\" in f . keys (): raise KeyError ( f 'no \"days\" in footnote \" { f [ \"text\" ] } \"' ) else : if not isinstance ( f [ \"days\" ], list ): daylist = [ f [ \"days\" ]] else : daylist = f [ \"days\" ] for d in decode_daylist ( daylist ): i = day_index ( period , d ) out [ 0 ][ i ] = True if out [ 1 ][ i ]: out [ 1 ][ i ] += \",\" out [ 1 ][ i ] += str ( f [ 'symbol' ]) out [ 2 ] . append ([ f [ 'symbol' ], f [ 'text' ]]) return ( out ) return ( iterate_over_procedures ( period , caption , out , temp ))","title":"extract_footnotes()"},{"location":"td/#td.extract_procedure","text":"get specified administration/procedure as list of tuples (day, [times], relative) for individual days Source code in trialdesign/td.py def extract_procedure ( period , caption ): \"\"\"get specified administration/procedure as list of tuples (day, [times], relative) for individual days\"\"\" out = [] def temp ( proc , out ): if 'times' in proc . keys (): t = proc [ 'times' ] elif 'freq' in proc . keys () and proc [ 'freq' ] == 'rich' : t = [ 0 , 0 ] else : t = [ 0 ] if 'relative' in proc . keys (): rel = proc [ 'relative' ] else : rel = 1 out += [( d , t , rel ) for d in decode_daylist ( proc [ 'days' ])] return ( out ) return ( iterate_over_procedures ( period , caption , out , temp ))","title":"extract_procedure()"},{"location":"td/#td.extract_start_end","text":"from day list, extract start and end days of trains of days Source code in trialdesign/td.py def extract_start_end ( daylist ): \"\"\"from day list, extract start and end days of trains of days\"\"\" last_day = 0 out = [] if daylist : daylist . sort () for i in daylist : if i == daylist [ 0 ] or i != last_day + 1 and not ( last_day == - 1 and i == 1 ): out += [ last_day , i ] last_day = i out += [ i ] out = list ( dict . fromkeys ( out )) if 0 in out : out . remove ( 0 ) return ( out )","title":"extract_start_end()"},{"location":"td/#td.has_timescale","text":"test if procedure has timescale in the respective period Source code in trialdesign/td.py def has_timescale ( period , caption ): \"\"\"test if procedure has timescale in the respective period\"\"\" out = [] def temp ( proc , out ): if 'timescale' in proc . keys (): if proc [ 'timescale' ] == 'show' : out . append ( True ) return ( out ) return ( True in iterate_over_procedures ( period , caption , out , temp ))","title":"has_timescale()"},{"location":"td/#td.item_names","text":"return list of interval/administration/procedure names for trial Source code in trialdesign/td.py def item_names ( periods , item_class ): \"\"\"return list of interval/administration/procedure names for trial\"\"\" out = [] for p in periods : if item_class in p . keys (): for proc in p [ item_class ]: temp = proc [ 'caption' ] if not temp in out : out . append ( temp ) return ( out )","title":"item_names()"},{"location":"td/#td.normalize_procedure","text":"break down procedure times to subsequent days, if longer than 24 h Source code in trialdesign/td.py def normalize_procedure ( procedure ): \"\"\"break down procedure times to subsequent days, if longer than 24 h\"\"\" out = [] for ( d , t , rel ) in procedure : dd = 0 while t : temp = [ i for i in t if i < 24 ] if temp : out . append (( d + dd , temp , rel )) t = [ i - 24 for i in t if i >= 24 ] dd += 1 return ( out )","title":"normalize_procedure()"},{"location":"td/#td.period_day_centers","text":"return list of x-coordinates for day centers Source code in trialdesign/td.py def period_day_centers ( period , xoffset , daywidth_function ): \"\"\"return list of x-coordinates for day centers\"\"\" return ([ start + width / 2 for start , width in zip ( period_day_starts ( period , xoffset , daywidth_function ), daywidth_function ( period ))])","title":"period_day_centers()"},{"location":"td/#td.period_day_ends","text":"return list of x-coordinates for day ends Source code in trialdesign/td.py def period_day_ends ( period , xoffset , daywidth_function ): \"\"\"return list of x-coordinates for day ends\"\"\" starts = period_day_starts ( period , xoffset , daywidth_function ) widths = daywidth_function ( period ) return ([ s + w for s , w in zip ( starts , widths )])","title":"period_day_ends()"},{"location":"td/#td.period_day_starts","text":"return list of x-coordinates for day starts Source code in trialdesign/td.py def period_day_starts ( period , xoffset , daywidth_function ): \"\"\"return list of x-coordinates for day starts\"\"\" out = [ xoffset ] acc = xoffset for i in daywidth_function ( period ): acc += i out . append ( acc ) return out [: - 1 ]","title":"period_day_starts()"},{"location":"td/#td.render_daygrid","text":"render svg output for the day grid for a period. Output is [svg_output, height] Source code in trialdesign/td.py def render_daygrid ( period , caption , xoffset , yoffset , height , metrics , style , first_pass = True ): \"\"\"render svg output for the day grid for a period. Output is [svg_output, height]\"\"\" ( daywidth_function , textwidth_function , textheight_function ) = metrics ( periodspacing , lineheight , ypadding , lwd , ellipsis , debug ) = style svg_out = \"\" y = yoffset if debug : svg_out += render_dummy ( period , xoffset , yoffset , height , metrics ) for start , width , center , label , shading in zip ( period_day_starts ( period , xoffset , daywidth_function ), daywidth_function ( period ), period_day_centers ( period , xoffset , daywidth_function ), day_labels ( period ), day_shadings ( period )): if shading : svg_out += svg_rect ( start , y , width , height , lwd = 0 , fill_color = \"lightgray\" ) if width > textwidth_function ( \"XX\" ) / 3 : svg_out += svg_rect ( start , y , width , height , lwd = lwd ) else : svg_out += svg_line ( start , y , start + width , y , lwd = lwd , dashed = True ) svg_out += svg_line ( start , y + height , start + width , y + height , lwd = lwd , dashed = True ) label = str ( label ) delta = textwidth_function ( \"1\" ) * .5 if label and label [ 0 ] == \"1\" else 0 if width > textwidth_function ( str ( label )): svg_out += svg_text ( center - textwidth_function ( str ( label )) / 2 - delta , yoffset + height - ( height - textheight_function ( \"X\" )) / 2 , str ( label )) return ([ svg_out , height + ypadding * 2 ])","title":"render_daygrid()"},{"location":"td/#td.render_dose_graph","text":"render dose over time for administration. Output is [svg_output, height] Source code in trialdesign/td.py def render_dose_graph ( period , caption , xoffset , yoffset , lineheight , metrics , style , first_pass = True ): \"\"\"render dose over time for administration. Output is [svg_output, height]\"\"\" ( daywidth_function , textwidth_function , textheight_function ) = metrics ( periodspacing , lineheight , ypadding , lwd , ellipsis , debug ) = style svg_out = \"\" if debug : svg_out += render_dummy ( period , xoffset , yoffset , lineheight + textheight_function ( \"X\" ), metrics ) startx = period_day_starts ( period , xoffset , daywidth_function ) endx = period_day_ends ( period , xoffset , daywidth_function ) doses = [ i for i in extract_field ( period , caption , \"dose\" )] doses_num = [ i for i in doses if isinstance ( i , int ) or isinstance ( i , float )] if len ( doses_num ): maxdose , mindose = max ( doses_num ), min ( doses_num ) def dosey ( dose ): return ( yoffset + lineheight * 0.6 - ( dose - mindose ) / ( maxdose - mindose ) * lineheight * 0.6 ) # if doses: lastx , lasty , lastdose = 0 , 0 , 0 lastend = 0 for ( s , e , d ) in zip ( startx , endx , doses ): if type ( d ) == int or type ( d ) == float : svg_out += svg_line ( s , dosey ( d ), e , dosey ( d ), lwd = lwd ) if lasty : svg_out += svg_line ( lastx , lasty , s , dosey ( d ), lwd = lwd ) lastx , lasty = e , dosey ( d ) if d != lastdose : if lastend + textwidth_function ( \"n\" ) < s : svg_out += svg_text ( s , yoffset + lineheight + textheight_function ( \"X\" ), str ( d )) lastend = s + textwidth_function ( str ( d )) lastdose = d return ([ svg_out , lineheight + textheight_function ( \"X\" ) + ypadding ])","title":"render_dose_graph()"},{"location":"td/#td.render_dummy","text":"render bounding box for visual debugging purposes. Output is svg code only. Source code in trialdesign/td.py def render_dummy ( period , xoffset , yoffset , lineheight , metrics ): \"\"\"render bounding box for visual debugging purposes. Output is svg code only.\"\"\" daywidth_function = metrics [ 0 ] return ( svg_rect ( xoffset , yoffset , period_width ( period , daywidth_function ), lineheight , lwd = 0 , fill_color = \"cornsilk\" ))","title":"render_dummy()"},{"location":"td/#td.render_interval","text":"render interval for procedure. Output is [svg_output, height] Source code in trialdesign/td.py def render_interval ( period , caption , xoffset , yoffset , lineheight , metrics , style , first_pass = True ): \"\"\"render interval for procedure. Output is [svg_output, height]\"\"\" ( daywidth_function , textwidth_function , textheight_function ) = metrics ( periodspacing , lineheight , ypadding , lwd , ellipsis , debug ) = style svg_out = \"\" y = yoffset + lineheight / 2 if debug : svg_out += render_dummy ( period , xoffset , yoffset , lineheight , metrics ) if first_pass : svg_out += svg_text ( 5 , y + textheight_function ( caption ) * ( 1 / 2 - 0.1 ), caption ) # render interval box starts = period_day_starts ( period , xoffset , daywidth_function ) ends = period_day_ends ( period , xoffset , daywidth_function ) widths = daywidth_function ( period ) height = 0.4 * lineheight if 'intervals' in period . keys (): for intv in period [ 'intervals' ]: if intv [ 'caption' ] == caption : if \"start\" in intv . keys () and \"duration\" in intv . keys (): start_list , duration_list = [ intv [ 'start' ]], [ intv [ 'duration' ]] elif \"days\" in intv . keys () and isinstance ( intv [ \"days\" ], list ): start_list = decode_daylist ( intv [ \"days\" ]) duration_list = [ 1 for i in decode_daylist ( intv [ \"days\" ])] else : raise TypeError ( f ' { period [ \"caption\" ] } , interval \" { intv [ \"caption\" ] } \"' ) for start , duration in zip ( start_list , duration_list ): startx = starts [ day_index ( period , start )] end = start + duration - 1 if start < 0 and end > 0 : end += 1 endx = ends [ day_index ( period , end )] if \"decoration\" in intv . keys (): if intv [ \"decoration\" ] == \"bracketed\" : wo = widths [ day_index ( period , start )] wc = widths [ day_index ( period , end )] svg_out += svg_open_bracket ( startx , y , lineheight , wo * .6 , xpadding = 0 , radius = lineheight / 8 , lwd = lwd ) svg_out += svg_close_bracket ( endx , y , lineheight , wc * .6 , xpadding = 0 , radius = lineheight / 8 , lwd = lwd ) svg_out += svg_rect ( startx , y - height / 2 , endx - startx , height , lwd = lwd ) return ([ svg_out , lineheight + ypadding ])","title":"render_interval()"},{"location":"td/#td.render_periodcaption","text":"render caption for period. The 'caption' input is ignored and the caption field of the input period is used. Output is [svg_output, height] Source code in trialdesign/td.py def render_periodcaption ( period , caption , xoffset , yoffset , height , metrics , style , first_pass = True ): \"\"\"render caption for period. The 'caption' input is ignored and the caption field of the input period is used. Output is [svg_output, height]\"\"\" ( daywidth_function , textwidth_function , textheight_function ) = metrics ( periodspacing , lineheight , ypadding , lwd , ellipsis , debug ) = style svg_out = \"\" if debug : svg_out += render_dummy ( period , xoffset , yoffset , height , metrics ) xcenter = xoffset + period_width ( period , daywidth_function ) / 2 svg_out += svg_text ( xcenter - textwidth_function ( str ( period [ 'caption' ])) / 2 , yoffset + height - ( height - textheight_function ( \"X\" )) / 2 , str ( period [ 'caption' ])) return ([ svg_out , height + ypadding / 2 ])","title":"render_periodcaption()"},{"location":"td/#td.render_periods","text":"applies rendering function to all periods Source code in trialdesign/td.py def render_periods ( periods , x , y , caption , height , render_function , metrics , style , dashes = False , footnotes = False , ** kwargs ): \"\"\"applies rendering function to all periods\"\"\" daywidth_function = metrics [ 0 ] ( periodspacing , lineheight , ypadding , lwd , ellipsis , debug ) = style w = [ period_width ( i , daywidth_function ) for i in periods ] first = True last = False h = 0 out = \"\" # render labels, if applicable has_labels = len ([ i for ii in [ extract_labels ( p , caption ) for p in periods ] for i in ii if i != '' ]) != 0 has_footnotes = True in [ i for ii in [ extract_footnotes ( p , caption )[ 0 ] for p in periods ] for i in ii ] if not footnotes : has_footnotes = False if has_labels or has_footnotes : xx = x for p in periods : [ svg_out , y_out ] = render_labels_footnotes ( p , caption , xx , y , height , metrics , style , footnotes = footnotes ) out += svg_out xx += period_width ( p , daywidth_function ) + periodspacing h += lineheight y += h # render procedure for p in periods : if p == periods [ - 1 ]: last = True [ svg_out , y_out ] = render_function ( p , caption , x , y , height , metrics , style , first_pass = first , ** kwargs ) out += svg_out if dashes and not last : out += svg_line ( x + period_width ( p , daywidth_function ), y + height / 2 , x + period_width ( p , daywidth_function ) + periodspacing , y + height / 2 , lwd = lwd ) x += period_width ( p , daywidth_function ) + periodspacing first = False return ( add_output ([ \"\" , h ], [ out , y_out ]))","title":"render_periods()"},{"location":"td/#td.render_procedure","text":"render procedure. Output is [svg_output, height] Source code in trialdesign/td.py def render_procedure ( period , caption , xoffset , yoffset , lineheight , metrics , style , default_symbol = \"diamond\" , first_pass = True ): \"\"\"render procedure. Output is [svg_output, height]\"\"\" ( daywidth_function , textwidth_function , textheight_function ) = metrics ( periodspacing , lineheight , ypadding , lwd , ellipsis , debug ) = style svg_out = \"\" if debug : svg_out += render_dummy ( period , xoffset , yoffset , lineheight , metrics ) y = yoffset + lineheight / 2 # center of the line if first_pass : svg_out += svg_text ( 5 , y + textheight_function ( caption ) * ( 1 / 2 - 0.1 ), caption ) centers = period_day_centers ( period , xoffset , daywidth_function ) widths = daywidth_function ( period ) brackets = extract_field ( period , caption , \"decoration\" ) symbols = procedure_symbols ( period , caption , default_symbol ) dlabels = day_labels ( period ) values = extract_field ( period , caption , \"value\" ) ellipses = [ 1 if ( s != \"\" and l == \"\" and len ( symbols ) > 3 ) else 0 for ( s , l ) in zip ( symbols , dlabels )] for p , w , s , b , e , v in zip ( centers , widths , symbols , brackets , ellipses , values ): if s : if e == 1 and b == \"\" and ellipsis : svg_out += svg_circle ( p , y , lineheight / 30 , fill_color = \"black\" ) elif v != \"\" : if v == 0 : svg_out += svg_symbol ( p , y , w * .5 , \"circle\" , fill = False , fill_color = \"none\" , lwd = lwd ) else : svg_out += svg_symbol ( p , y , w * .5 , \"circle\" , fill = True , fill_color = \"black\" ) else : svg_out += svg_symbol ( p , y , w , s , size = textheight_function ( \"X\" ), lwd = lwd , title = caption ) if b == \"bracketed\" : svg_out += svg_open_bracket ( p , y , lineheight , w * .8 , xpadding = 0 , radius = lineheight / 8 , lwd = lwd ) svg_out += svg_close_bracket ( p , y , lineheight , w * .8 , xpadding = 0 , radius = lineheight / 8 , lwd = lwd ) return ([ svg_out , lineheight + ypadding ])","title":"render_procedure()"},{"location":"td/#td.render_times","text":"render timescale for procedure. Output is [svg_output, height] Source code in trialdesign/td.py def render_times ( period , caption , xoffset , yoffset , lineheight , metrics , style , maxwidth = 100 ): \"\"\"render timescale for procedure. Output is [svg_output, height]\"\"\" ( daywidth_function , textwidth_function , textheight_function ) = metrics ( periodspacing , lineheight , ypadding , lwd , ellipsis , debug ) = style out = \"\" proc = normalize_procedure ( extract_procedure ( period , caption )) ts_days = [] for x in [ 'procedures' , 'administrations' ]: if x in period . keys (): for p in period [ x ]: if p [ 'caption' ] == caption : if \"timescale\" in p . keys () and p [ \"timescale\" ] == \"show\" : ts_days . append ( p [ \"relative\" ]) ts_days = set ( ts_days ) y = yoffset bracketheight = lineheight * 2 / 3 last_scale_end = 0 if ts_days : ## curly brackets if debug : out += render_dummy ( period , xoffset , y , bracketheight , metrics ) for ts_d in ts_days : times = unnormalize_procedure ([ i for i in proc if i [ 2 ] == ts_d ])[ 0 ][ 1 ] startx = period_day_starts ( period , xoffset , daywidth_function )[ day_index ( period , min ([ i for ( i , t , rel ) in proc if rel == ts_d ]))] endx = period_day_ends ( period , xoffset , daywidth_function )[ day_index ( period , max ([ i for ( i , t , rel ) in proc if rel == ts_d ]))] radius = bracketheight / 2 if radius * 4 > endx - startx : startx -= radius / 2 endx += radius / 2 radius = ( endx - startx ) / 5 out += svg_curly_up ( startx , endx , y , radius = radius , lwd = lwd ) y += bracketheight + ypadding * 1.5 ## timescales if debug : out += render_dummy ( period , xoffset , y , lineheight * 1.33 + ypadding * 2 + textheight_function ( \"X\" ), metrics ) for ts_d in ts_days : times = unnormalize_procedure ([ i for i in proc if i [ 2 ] == ts_d ])[ 0 ][ 1 ] maxtime = max ( times ) break_time = min ( sorted ( list ([ i for i in times if i < 24 ]))[ - 1 ] + 2 , 23 ) times_below = len ([ i for i in times if i <= break_time ]) times_above = len ([ i for i in times if i > break_time ]) startx = period_day_starts ( period , xoffset , daywidth_function )[ day_index ( period , min ([ i for ( i , t , rel ) in proc if rel == ts_d ]))] ### scale scale_height = lineheight / 3 scale_width = min ( len ( times ) * textwidth_function ( \"XX\" ), maxwidth - xoffset ) scale_break = scale_width * times_below / ( times_below + times_above ) scale_gap = textwidth_function ( \"m\" ) scale_startx = max ( min ( startx , xoffset + period_width ( period , daywidth_function ) - scale_width ), xoffset ) if scale_startx < last_scale_end : y += lineheight * 1.33 + ypadding * 3 + textheight_function ( \"X\" ) def render_scale ( x , y , width , height , scale_min , scale_max , scale_labels , show_unit = False ): out = svg_line ( x , y , x + width , y , lwd = lwd ) label_widths = [ textwidth_function ( str ( i )) for i in scale_labels ] last_label_end = 0 final_label_begin = x + width - label_widths [ - 1 ] / 2 min_delta = textwidth_function ( \".\" ) for i , wi in zip ( scale_labels , label_widths ): xi = ( i - scale_min ) * width / ( scale_max - scale_min ) + x out += svg_line ( xi , y - height / 2 , xi , y + height / 2 , lwd = lwd ) dxi = wi / 2 if xi - dxi > last_label_end and xi + dxi < final_label_begin - min_delta : out += svg_text ( xi - dxi , y + height / 2 + textheight_function ( \"X\" ) + ypadding , str ( i )) last_label_end = xi + dxi + min_delta if i == scale_labels [ - 1 ]: temp = str ( i ) if show_unit : temp += \" h\" out += svg_text ( xi - dxi , y + height / 2 + textheight_function ( \"X\" ) + ypadding , temp ) return ( out ) def render_points ( x , y , width , scale_min , scale_max ): points = [ t for t in times if t >= scale_min and t <= scale_max ] points_x = [( i - scale_min ) * width / ( scale_max - scale_min ) + x for i in points ] out = \"\" for p , xi in zip ( points , points_x ): out += svg_symbol ( xi , y + lineheight / 2 , 0 , \"diamond\" , size = textheight_function ( \"X\" ), lwd = lwd ) return ( out ) out += render_points ( scale_startx , y , scale_break , 0 , break_time ) out += render_points ( scale_startx + scale_break + scale_gap , y , scale_width - scale_gap - scale_break , 24 , max ( maxtime , 36 )) out += render_scale ( scale_startx , y + lineheight + ypadding , scale_break , scale_height , 0 , break_time , range ( 0 , int ( break_time ), 2 )) if maxtime >= 24 : out += render_scale ( scale_startx + scale_break + scale_gap , y + lineheight + ypadding , scale_width - scale_gap - scale_break , scale_height , 24 , max ( maxtime , 36 ), [ i * 24 for i in range ( 1 , int ( maxtime / 24 + 1 ))], show_unit = True ) last_scale_end = scale_startx + scale_width return ([ out , y + lineheight * 1.33 + ypadding * 3 + textheight_function ( \"X\" ) - yoffset ])","title":"render_times()"},{"location":"td/#td.unnormalize_procedure","text":"collate procedure times into single day, if relative to the same day Source code in trialdesign/td.py def unnormalize_procedure ( procedure ): \"\"\" collate procedure times into single day, if relative to the same day\"\"\" out = [] if procedure : rels = set ([ r for ( d , ts , r ) in procedure ]) for rel in rels : current_times = [] for ( d , ts , r ) in procedure : for t in ts : if r == rel : current_times . append ( t + ( d - r ) * 24 ) out . append (( rel , current_times , rel )) return ( out )","title":"unnormalize_procedure()"},{"location":"use/","text":"Using TD This gives an overview on how to run the td tool from the command line. Requirements TD is written in python 3. In order to run the tool on your system, python 3 must be installed. You can find out which version of python is installed (or is the default) on your system with python --version . In addition, td.py makes use of the below libraries: click pathlib cairo json math re sys These packages need to be installed with pip install [library] . Running TD Generally, it is assumed that only python 3 is installed on the host system. TD can then be executed from the command line with: python td.py [FLAGS] [INPUT] where INPUT is the json-formatted input file (see Input for details). The optional FLAGS can be used to further specify the visual output. In cases where both python 3 and python 2.7 are installed on the host system, it may be necessary to be specific about the python version to be used, this can be achieved using the python3 td.py [FLAGS] [INPUT] command. The available option flags can be shown with python3 td.py --help . In the current version of TD, they include: Option Alternative Description --output TEXT -o Output file name. Default: INPUT.svg --fontsize INTEGER -s Output font size (default 11) --font TEXT -f Output font type (default: Arial) --padding FLOAT -p Y-axis padding factor (default 1) --condensed -c Show condensed daygrid --timescale -t Show time scale --graph -g Show dose graph --ellipsis -e Reduce symbols in condensed output --footnotes -n Show footnotes --all -A All options, equivalent to -ctge --debug -d Debug output --help -h Show this message and exit. Output file The default output file name is the input file name (e.g., \"test.json\") with the .svg extension (i.e., \"test.svg\"). This can be overridden with the --output or -o option. Font size and family The default font is Arial 11 point. Both font and size can be overridden using the --font ( -f ) and --fontsize ( -s ) options. The available font families depend on the fonts installed on the target system. In addition, the generated svg file can be scaled in the target application (e.g., MS PowerPoint), and any element can be reformatted separately. Padding The parameter --padding ( -p ) increases or decreases the vertical space between period elements. The default of 1 should work in most cases. Condensed This option can be used to compress the output horizontally. Days that have no daylabel ( see \"period formatting\" ) assigned will be rendered narrower. As an example, the following figure was rendered normally (using python td.py test.json ): The below version was rendered with the --condensed option ( python td.py --condensed test.json ): Ellipsis In addition to condensed output, daily recurring procedure symbols that visually clutter the output can be reduced using the --ellipsis or -e option. This is only done for days that have no daylabel. The below version was rendered using python td.py -ce test.json for a combination of condensed and ellipsis output: Timescale Procedures that have exact time information included in the input file, e.g., PK samplings (see \"exact procedure times\" ), can be displayed with an inset figure underneath that shows the timescale detail. The following output was generated using the python td.py --condensed --timescale test.json command: Note that that there must be the \"timescale\": \"show\" line included in the json input file for this procedure (see \"exact procedure times\" ). For visual clarity, display of a timescale should be limited to the last element (the one at the bottom) of a trial design visualization. Dose graph In cases where intraindividual dose escalation occurs, e.g., to phase a drug in or out, a dose graph can be shown underneath the administration symbols to indicate dose over time. A prerequisite is that the respective dosing information is included per day in the input file (see Input ). The following output was created using the python td.py --condensed --graph test.json command to include a dose graph for carbamazepine: Footnotes If footnotes have been defined in the input file (see Input ), they can be rendered in the output using the \"--footnotes\" (or \"-n\") option.","title":"Use"},{"location":"use/#using-td","text":"This gives an overview on how to run the td tool from the command line.","title":"Using TD"},{"location":"use/#requirements","text":"TD is written in python 3. In order to run the tool on your system, python 3 must be installed. You can find out which version of python is installed (or is the default) on your system with python --version . In addition, td.py makes use of the below libraries: click pathlib cairo json math re sys These packages need to be installed with pip install [library] .","title":"Requirements"},{"location":"use/#running-td","text":"Generally, it is assumed that only python 3 is installed on the host system. TD can then be executed from the command line with: python td.py [FLAGS] [INPUT] where INPUT is the json-formatted input file (see Input for details). The optional FLAGS can be used to further specify the visual output. In cases where both python 3 and python 2.7 are installed on the host system, it may be necessary to be specific about the python version to be used, this can be achieved using the python3 td.py [FLAGS] [INPUT] command. The available option flags can be shown with python3 td.py --help . In the current version of TD, they include: Option Alternative Description --output TEXT -o Output file name. Default: INPUT.svg --fontsize INTEGER -s Output font size (default 11) --font TEXT -f Output font type (default: Arial) --padding FLOAT -p Y-axis padding factor (default 1) --condensed -c Show condensed daygrid --timescale -t Show time scale --graph -g Show dose graph --ellipsis -e Reduce symbols in condensed output --footnotes -n Show footnotes --all -A All options, equivalent to -ctge --debug -d Debug output --help -h Show this message and exit.","title":"Running TD"},{"location":"use/#output-file","text":"The default output file name is the input file name (e.g., \"test.json\") with the .svg extension (i.e., \"test.svg\"). This can be overridden with the --output or -o option.","title":"Output file"},{"location":"use/#font-size-and-family","text":"The default font is Arial 11 point. Both font and size can be overridden using the --font ( -f ) and --fontsize ( -s ) options. The available font families depend on the fonts installed on the target system. In addition, the generated svg file can be scaled in the target application (e.g., MS PowerPoint), and any element can be reformatted separately.","title":"Font size and family"},{"location":"use/#padding","text":"The parameter --padding ( -p ) increases or decreases the vertical space between period elements. The default of 1 should work in most cases.","title":"Padding"},{"location":"use/#condensed","text":"This option can be used to compress the output horizontally. Days that have no daylabel ( see \"period formatting\" ) assigned will be rendered narrower. As an example, the following figure was rendered normally (using python td.py test.json ): The below version was rendered with the --condensed option ( python td.py --condensed test.json ):","title":"Condensed"},{"location":"use/#ellipsis","text":"In addition to condensed output, daily recurring procedure symbols that visually clutter the output can be reduced using the --ellipsis or -e option. This is only done for days that have no daylabel. The below version was rendered using python td.py -ce test.json for a combination of condensed and ellipsis output:","title":"Ellipsis"},{"location":"use/#timescale","text":"Procedures that have exact time information included in the input file, e.g., PK samplings (see \"exact procedure times\" ), can be displayed with an inset figure underneath that shows the timescale detail. The following output was generated using the python td.py --condensed --timescale test.json command: Note that that there must be the \"timescale\": \"show\" line included in the json input file for this procedure (see \"exact procedure times\" ). For visual clarity, display of a timescale should be limited to the last element (the one at the bottom) of a trial design visualization.","title":"Timescale"},{"location":"use/#dose-graph","text":"In cases where intraindividual dose escalation occurs, e.g., to phase a drug in or out, a dose graph can be shown underneath the administration symbols to indicate dose over time. A prerequisite is that the respective dosing information is included per day in the input file (see Input ). The following output was created using the python td.py --condensed --graph test.json command to include a dose graph for carbamazepine:","title":"Dose graph"},{"location":"use/#footnotes","text":"If footnotes have been defined in the input file (see Input ), they can be rendered in the output using the \"--footnotes\" (or \"-n\") option.","title":"Footnotes"}]}